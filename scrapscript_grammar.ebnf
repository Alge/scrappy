(* ======================================== *)
(*     The ScrapScript Language Grammar     *)
(* ======================================== *)

(* --- Top-Level Structure --- *)
(* A program consists of one or more statements, separated by ";" *)
(* At the end of a program there might be any number of semicolons (including 0) *)

program ::= statement (";" + statement)* ";"*


(* --- Statements ---*)
(* A statment consists of either        *)
(*   - A expression statment            *)
(*   - A function definition            *)
(*   - A type definition                *)

statement ::= expression_statement | function_definition | type_definition

(* Function definitions *)

function_definition ::= IDENTIFIER "=" expression

(* Type definitions *)

type_definition ::= IDENTIFIER ":" type_constructor type_expression

type_expression ::= type_variant_clause+

type_variant_clause ::= ["|"] type_variant

type_variant ::= ATOM [type_parameter]

type_parameter ::= IDENTIFIER | "(" type_expression ")"

type_constructor ::= (IDENTIFIER "=>")*



(* --- expressions ---*)
(* Expressions consists of a prefix expression followed by any number *)
(* of infix operations. This corresponds to the Pratt parser implemented *)

expression_statement ::= expression


expression ::= prefix_expression (infix_operation)*

pattern_match_expression ::= ("|" pattern "->" expression)+

pattern ::= literal_pattern
          | IDENTIFIER  
          | "_"
          | list_pattern
          | record_pattern
          | variant_pattern
          | text_pattern

list_pattern ::= "[" "]"
               | "[" pattern ("," pattern)* "]" 
               | "[" pattern ("," pattern)* "]" "++" pattern
               | pattern ">+" pattern

text_pattern ::= TEXT "++" pattern

variant_pattern ::= "#" IDENTIFIER [pattern]*

record_pattern ::= "{" [record_pattern_field ("," record_pattern_field)*] "}"
record_pattern_field ::= IDENTIFIER "=" pattern | ".." pattern

infix_operation ::= infix_operator expression

prefix_expression ::= IDENTIFIER
                    | unary_expression  
                    | "(" expression ")"
                    | literal
                    | pattern_match_expression
                    | record_expression
                    | variant_construction
                    | list_literal
                    | function_application

function_application ::= prefix_expression (prefix_expression)+

list_literal ::= "[" [ expression ("," expression)* ] "]"


(* Instantiate a object from a type *)
variant_construction ::= IDENTIFIER "::" IDENTIFIER prefix_expression*

record_expression ::= "{" [record_field ("," record_field)*] "}"
record_field ::= IDENTIFIER ":" expression

unary_expression ::= prefix_operator expression

(* Binary expressions are implicit from the above, as *)
(* "expression infix_operator expression" already matches the rules *)
(* binary_expression ::= expression infix_operator expression *)

infix_operator ::= ";" | "=" | "->" | "+" | "-" | "*" | "/" | "++" | "+<" | ">+" | ">>"
prefix_operator ::= "-" | "!"

literal ::= INTEGER | FLOAT | TEXT | HEX_BYTE | BASE64 | HOLE

(* ======================================================= *)
(*   Precedence and Associativity Table                    *)
(* ======================================================= *)
(* ------------------------------------------------------- *)
(* | Operator | Type  | Precedence | Associativity         *)
(* ------------------------------------------------------- *)
(* | ;      | Infix | 1      | Right                       *)
(* | =      | Infix | 2      | Right                       *)
(* | >>     | Infix | 3      | Left                        *)
(* | ->     | Infix | 5      | Right                       *)
(* | ++     | Infix | 6      | Right                       *)
(* | + -    | Infix | 10     | Left                        *)
(* | +< >+  | Infix | 11     | Left                        *)
(* | * /    | Infix | 20     | Left                        *)
(* | - !    | Prefix| 30     | (N/A - Right)               *)
(* | App    | Infix | 40     | Left (implicit)             *)
(* ------------------------------------------------------- *)
